### 几种常用的线程模型
#### 1.Future模型
该模型通常在使用的时候需要结合Callable接口配合使用。Future是把结果放在将来获取，
当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，
处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。
Callable是类似于Runnable的接口，其中call方法类似于run方法，
`所不同的是run方法不能抛出受检异常没有返回值，而call方法则可以抛出受检异常并可设置返回值。`
两者的方法体都是线程执行体。

#### 2.fork&join模型
该模型是jdk中提供的线程模型。该模型包含递归思想和回溯思想，递归用来拆分任务，
回溯用合并结果。 可以用来处理一些可以进行拆分的大任务。
其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，
当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果。

#### 3.生产者消费者模型
生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。
开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。
这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，
只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。
使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。
比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，
这样就可以避免任务的处理响应缓慢的问题。

#### 4.actor模型
在使用Java进行并发编程时需要特别的关注锁和内存原子性等一系列线程问题，而Actor模型内部的状态由它自己维护即它内部数据只能由它自己修改
(通过消息传递来进行状态修改)，所以使用Actors模型进行并发编程可以很好地避免这些问题，Actor由状态(state)、
行为(Behavior)和邮箱(mailBox)三部分组成
1. 状态(state)：Actor中的状态指的是Actor对象的变量信息，状态由Actor自己管理，避免了并发环境下的锁和内存原子性等问题
2. 行为(Behavior)：行为指定的是Actor中计算逻辑，通过Actor接收到消息来改变Actor的状态
3. 邮箱(mailBox)：邮箱是Actor和Actor之间的通信桥梁，邮箱内部通过FIFO消息队列来存储发送方Actor消息，接受方Actor从邮箱队列中获取消息

#### 5.master&worker模型
 Master-Worker模式是常用的并行模式之一，它的核心思想是，系统有两个进程协作工作：
 Master进程，负责接收和分配任务；Worker进程，负责处理子任务。
 当Worker进程将子任务处理完成后，结果返回给Master进程，由Master进程做归纳汇总，最后得到最终的结果。
 Master-Worker模式是一种将串行任务并行化的方案，被分解的子任务在系统中可以被并行处理，
 同时，如果有需要，Master进程不需要等待所有子任务都完成计算，就可以根据已有的部分结果集计算最终结果集。
